/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.example

import java.util.LinkedList

class Calculator {

    fun calculateExpression(expression: String): Int {
        return 0
    }


}

enum class TokenType(val priority: Int) {
    NUMBER(-1),
    PLUS(0),
    MINUS(0),
    MUL(10),
    DIV(10),
    PARENTHESES_OPEN(20),
    PARENTHESES_CLOSE(20)
}

data class Token(
    val type: TokenType,
    val value: String
)

fun parse(str: String): List<Token> {
    var i = 0
    val result = mutableListOf<Token>()

    while (i < str.length) {
        when (str[i]) {
            '+' -> result.add(Token(TokenType.PLUS, "+"))
            '-' -> result.add(Token(TokenType.MINUS, "-"))
            '*' -> result.add(Token(TokenType.MUL, "*"))
            '/' -> result.add(Token(TokenType.DIV, "/"))
            '(' -> result.add(Token(TokenType.PARENTHESES_OPEN, "("))
            ')' -> result.add(Token(TokenType.PARENTHESES_CLOSE, ")"))
            else -> {
                if (str[i].isWhitespace()) {
                    i++
                    continue
                }

                val start = i
                while (i < str.length && str[i].isDigit()) {
                    i++
                }
                result.add(Token(TokenType.NUMBER, str.substring(start, i)))
                continue
            }
        }
        i++
    }

    return result
}

data class TokenHolder(
    val tokens: LinkedList<Token>
)

fun eval(tokens: List<Token>): Int {
    return eval(tokens.toCollection(LinkedList()))
}

fun eval(tokens: LinkedList<Token>): Int {
    if (tokens.isEmpty()) {
        throw IllegalArgumentException("Empty tokens")
    }

    val bucket = LinkedList<Token>()
    var i = 0

    while (tokens.isNotEmpty()) {
        val token = tokens.poll()

        // 5 + 5
        when (token.type) {
            TokenType.NUMBER -> {
                val nextOperator = tokens.peek()
                val lastOperator = bucket.peekLast()

                if (lastOperator == null) {
                    bucket.add(token)
                    continue
                }

                if (nextOperator != null && nextOperator.type.priority > lastOperator.type.priority) {
                    bucket.add(token)
                    continue
                }

                bucket.pollLast() // remove last operator
                when (lastOperator.type) {
                    TokenType.PLUS -> {
                        val lastNumber = bucket.pollLast()
                        val calculatedResult = Token(
                            type = TokenType.NUMBER,
                            value = (lastNumber.value.toInt() + token.value.toInt()).toString()
                        )
                        bucket.add(calculatedResult)
                    }

                    TokenType.MINUS -> {
                        val lastNumber = bucket.pollLast()
                        val calculatedResult = Token(
                            type = TokenType.NUMBER,
                            value = (lastNumber.value.toInt() - token.value.toInt()).toString()
                        )
                        bucket.add(calculatedResult)
                    }

                    TokenType.MUL -> {
                        val lastNumber = bucket.pollLast()
                        val calculatedResult = Token(
                            type = TokenType.NUMBER,
                            value = (lastNumber.value.toInt() * token.value.toInt()).toString()
                        )
                        bucket.add(calculatedResult)
                    }

                    TokenType.DIV -> {
                        val lastNumber = bucket.pollLast()
                        val calculatedResult = Token(
                            type = TokenType.NUMBER,
                            value = (lastNumber.value.toInt() / token.value.toInt()).toString()
                        )
                        bucket.add(calculatedResult)
                    }

                    else -> {

                    }
                }
            }

            TokenType.PLUS, TokenType.MINUS, TokenType.MUL, TokenType.DIV -> {
                bucket.add(token)
            }


            else -> {

            }
        }
    }

    if (bucket.size == 1) {
        return bucket.last.value.toInt()
    } else {
        return eval(bucket)
    }
}
